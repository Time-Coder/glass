#ifndef __BO__
#define __BO__

#include <unordered_map>

#include "glass/common.h"
#include "glass/utils/type.h"
#include "glass/utils/exceptions.h"

typedef unsigned int uint;

class BO
{
public:
	enum BufferType
	{
		VERTEX = GL_ARRAY_BUFFER,
		ELEMENT = GL_ELEMENT_ARRAY_BUFFER,
		UNIFORM = GL_UNIFORM_BUFFER,
		FRAME = GL_FRAMEBUFFER,
		RENDER = GL_RENDERBUFFER
	};

	enum MemoryType
	{
		STREAM = GL_STREAM_DRAW,
		STATIC = GL_STATIC_DRAW,
		DYNAMIC = GL_DYNAMIC_DRAW
	};

protected:
	struct Instance
	{
		size_t size = 0; // n_bytes
		uint n_sources = 0;
		MemoryType mem_type = STATIC;
		bool is_mapped = false;
	};

	static std::unordered_map<BufferType, std::unordered_map<uint, Instance> > existing_BOs;
	static std::unordered_map<BufferType, uint> active_BO;

protected:
	BufferType _buffer_type = VERTEX;
	uint _id = 0;

protected:
	virtual void init();
	virtual void del();
	virtual uint n_sources()const;

private:
	BufferType type()const;
	std::string type_str()const;

public:
	BO(BufferType buffer_type);
	BO(const BO& bo);
	BO(BO&& bo);
	BO& operator =(const BO& bo);
	BO& operator =(BO&& bo);
	virtual ~BO();
	virtual uint id()const;
	virtual void bind();
	virtual void unbind()const;
	virtual bool isBind()const;

	virtual void malloc(size_t n_bytes, MemoryType mem_type = STATIC);
	virtual void calloc(size_t n_elements, size_t sizeof_element, MemoryType mem_type = STATIC);
	virtual void realloc(size_t n_bytes, MemoryType mem_type = STATIC);
	virtual void memcpy(void* ptr_value, size_t n_bytes, MemoryType mem_type = STATIC);
	virtual void copyFrom(BO bo);
	virtual void free();

	virtual bool empty()const;
	virtual size_t size()const;
	virtual MemoryType memType()const;

	virtual void* ptr();
	virtual bool apply();

	template<class DataType>
	DataType clone();
};

class VBO;
class EBO;
class UBO;
class FBO;
class RBO;
template<class DataType>
DataType BO::clone()
{
	if(_buffer_type == VERTEX && !same_type(DataType*, VBO*))
		throw glass::TypeError("Cannot convert VBO to " + type_name(DataType));
	else if(_buffer_type == ELEMENT && !same_type(DataType*, EBO*))
		throw glass::TypeError("Cannot convert EBO to " + type_name(DataType));
	else if(_buffer_type == UNIFORM && !same_type(DataType*, UBO*))
		throw glass::TypeError("Cannot convert UBO to " + type_name(DataType));
	else if(_buffer_type == FRAME && !same_type(DataType*, FBO*))
		throw glass::TypeError("Cannot convert FBO to " + type_name(DataType));
	else if(_buffer_type == RENDER && !same_type(DataType*, RBO*))
		throw glass::TypeError("Cannot convert RBO to " + type_name(DataType));

	DataType result;
	if(empty())
	{
		return result;
	}

	result.malloc(size());
	bind();
	switch(_buffer_type)
	{
		case VERTEX:
		case ELEMENT:
		case UNIFORM:
			glBindBuffer(GL_COPY_WRITE_BUFFER, result._id);
			break;
		case FRAME:
			glBindFramebuffer(GL_COPY_WRITE_BUFFER, result._id);
			break;
		case RENDER:
			glBindRenderbuffer(GL_COPY_WRITE_BUFFER, result._id);
			break;
	}

	glCopyBufferSubData(_buffer_type, GL_COPY_WRITE_BUFFER, 0, 0, size());
	return result;
}

#endif